# Исправление проблемы с Exit Code 162

## Проблема
Скрипт выполняет `exit 4002`, но система возвращает код 162 вместо 4002.

## Причина
В Unix/Linux exit code ограничен 8 битами (0-255). Когда скрипт пытается выйти с кодом > 255 (например, 4002), система обрезает его до значения в диапазоне 0-255.

**4002 % 256 = 146**, но мы получаем 162, что может быть связано с особенностями обработки в Python subprocess или bash.

## Решение
Добавлен код для извлечения **реального exit code из STDERR**, где `bash -x` показывает команду `+ exit 4002`.

### Как это работает:
1. После выполнения скрипта проверяется STDERR
2. Ищется паттерн `+ exit 4002` (или `exit 4002`)
3. Извлекается реальный код ошибки
4. Если код >= 1000, он используется вместо обрезанного системного кода

### Код:
```python
# Extract actual exit code from stderr if bash -x was used
exit_pattern = r'\+?\s*exit\s+(\d+)'
matches = re.findall(exit_pattern, result.stderr)
if matches:
    last_exit = matches[-1]
    extracted_code = int(last_exit)
    if extracted_code >= 1000:
        actual_exit_code = extracted_code
```

## Результат
Теперь система правильно определяет exit code 4002 из STDERR и использует его для определения статуса проверки:
- 4002 → "Не пройдена" (строка закомментирована)
- 4001 → "Не пройдена" (строка не найдена)
- 4004 → "Не пройдена" (неверное значение)
- 5001 → "Ошибка" (отсутствует переменная)

## Что дальше
1. Перезапустите приложение
2. Запустите проверку снова
3. Проверьте логи - теперь должен быть правильный exit code 4002
4. Статус должен быть "Не пройдена" с правильным описанием ошибки

## Примечание
Это решение работает только когда используется `bash -x` (режим отладки). В продакшене можно:
1. Оставить `bash -x` для отладки
2. Или использовать другой механизм передачи кодов ошибок (например, через STDOUT)
